/**
 * Malware and Threat Detection Module
 * Integrates with Google Safe Browsing API and other threat intelligence with Effect Schema
 */

import * as S from "@effect/schema/Schema";
import axios from "axios";

// Effect Schema for threat match
export class ThreatMatch extends S.Class<ThreatMatch>("ThreatMatch")({
	threatType: S.String,
	platformType: S.String,
	threatEntryType: S.String,
	description: S.String,
}) {}

// Effect Schema for malware check result
export class MalwareCheckResult extends S.Class<MalwareCheckResult>("MalwareCheckResult")({
	isSafe: S.Boolean,
	url: S.String,
	threats: S.Array(
		S.Struct({
			threatType: S.String,
			platformType: S.String,
			threatEntryType: S.String,
			description: S.String,
		})
	),
	checkedBy: S.Array(S.String),
	errors: S.Array(S.String),
	warnings: S.Array(S.String),
	checkTime: S.Number,
}) {}

/**
 * Check URL against Google Safe Browsing API
 * Requires GOOGLE_SAFE_BROWSING_API_KEY environment variable
 */
export async function checkMalware(url: string): Promise<MalwareCheckResult> {
	const errors: string[] = [];
	const warnings: string[] = [];
	const threats: Array<{
		threatType: string;
		platformType: string;
		threatEntryType: string;
		description: string;
	}> = [];
	const checkedBy: string[] = [];
	const startTime = Date.now();

	// Check if API key is configured
	const apiKey = process.env.GOOGLE_SAFE_BROWSING_API_KEY;

	if (!apiKey) {
		warnings.push("Google Safe Browsing API key not configured - skipping malware check");
		return new MalwareCheckResult({
			isSafe: true,
			url,
			threats: [],
			checkedBy: [],
			errors: [],
			warnings,
			checkTime: Date.now() - startTime,
		});
	}

	try {
		checkedBy.push("Google Safe Browsing");

		const response = await axios.post(
			`https://safebrowsing.googleapis.com/v4/threatMatches:find?key=${apiKey}`,
			{
				client: {
					clientId: "link-shortener",
					clientVersion: "1.0.0",
				},
				threatInfo: {
					threatTypes: [
						"MALWARE",
						"SOCIAL_ENGINEERING",
						"UNWANTED_SOFTWARE",
						"POTENTIALLY_HARMFUL_APPLICATION",
					],
					platformTypes: ["ANY_PLATFORM"],
					threatEntryTypes: ["URL"],
					threatEntries: [{ url }],
				},
			},
			{
				timeout: 5000,
				headers: {
					"Content-Type": "application/json",
				},
			}
		);

		if (response.data.matches && response.data.matches.length > 0) {
			for (const match of response.data.matches) {
				threats.push({
					threatType: match.threatType,
					platformType: match.platformType,
					threatEntryType: match.threatEntryType,
					description: getThreatDescription(match.threatType),
				});
			}
		}
	} catch (error: any) {
		if (error.response?.status === 429) {
			errors.push("Safe Browsing API rate limit exceeded");
		} else if (error.code === "ECONNABORTED") {
			errors.push("Safe Browsing API request timed out");
		} else {
			errors.push(`Safe Browsing API error: ${error.message}`);
		}
	}

	return new MalwareCheckResult({
		isSafe: threats.length === 0 && errors.length === 0,
		url,
		threats,
		checkedBy,
		errors,
		warnings,
		checkTime: Date.now() - startTime,
	});
}

/**
 * Get human-readable description for threat types
 */
function getThreatDescription(threatType: string): string {
	const descriptions: Record<string, string> = {
		MALWARE: "The URL contains malware that may harm your device",
		SOCIAL_ENGINEERING: "The URL is used for phishing or social engineering attacks",
		UNWANTED_SOFTWARE: "The URL hosts unwanted software or potentially unwanted programs",
		POTENTIALLY_HARMFUL_APPLICATION: "The URL may contain harmful applications",
	};

	return descriptions[threatType] || "Unknown threat type";
}

/**
 * Additional heuristic malware checks (file extensions, etc.)
 */
export function checkSuspiciousPatterns(url: string): {
	suspicious: boolean;
	patterns: string[];
} {
	const patterns: string[] = [];
	const urlLower = url.toLowerCase();

	// Suspicious file extensions in URL
	const maliciousExtensions = [
		".exe", ".scr", ".bat", ".cmd", ".com", ".pif",
		".vbs", ".js", ".jar", ".apk", ".app", ".dmg",
		".deb", ".rpm", ".msi", ".dll",
	];

	for (const ext of maliciousExtensions) {
		if (urlLower.endsWith(ext) || urlLower.includes(ext + "?")) {
			patterns.push(`Contains suspicious executable extension: ${ext}`);
		}
	}

	// Double extensions (e.g., .pdf.exe)
	const doubleExtRegex = /\.(pdf|doc|docx|xls|xlsx|jpg|png|gif)\.(exe|scr|bat|cmd|vbs|js)/i;
	if (doubleExtRegex.test(url)) {
		patterns.push("Contains double extension (possible malware disguise)");
	}

	// Suspicious query parameters
	const suspiciousParams = ["download", "install", "update", "setup", "exec"];
	for (const param of suspiciousParams) {
		if (urlLower.includes(`${param}=`) || urlLower.includes(`/${param}/`)) {
			patterns.push(`Contains suspicious parameter: ${param}`);
		}
	}

	return {
		suspicious: patterns.length > 0,
		patterns,
	};
}
